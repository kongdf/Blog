 
# 前言
每个执行上下文，都有三个重要属性
* 变量对象(Variable object，VO)
* 作用域链(Scope chain)
* this

重点讲讲作用域链

# 作用域链
其实作用域链和原型链差不多，都是从当前上下文中查找，如果当前上下文没有，那么会去他的父级去找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。
# 函数创建
函数的作用域在函数定义的时候就决定了。
这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！

举个例子：
```js
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为:
```js
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```
# 函数激活

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。

这时候执行上下文的作用域链，我们命名为 Scope：
`Scope = [AO].concat([[Scope]]);`

至此，作用域链创建完毕。
